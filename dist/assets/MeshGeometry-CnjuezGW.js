import{b,a as h,v as p,B as a,c as s}from"./index-DDZL8cFr.js";const n=class f extends b{constructor(...e){let t=e[0]??{};t instanceof Float32Array&&(h(p,"use new MeshGeometry({ positions, uvs, indices }) instead"),t={positions:t,uvs:e[1],indices:e[2]}),t={...f.defaultOptions,...t};const r=t.positions||new Float32Array([0,0,1,0,1,1,0,1]);let i=t.uvs;i||(t.positions?i=new Float32Array(r.length):i=new Float32Array([0,0,1,0,1,1,0,1]));const u=t.indices||new Uint32Array([0,1,2,0,2,3]),o=t.shrinkBuffersToFit,d=new a({data:r,label:"attribute-mesh-positions",shrinkToFit:o,usage:s.VERTEX|s.COPY_DST}),l=new a({data:i,label:"attribute-mesh-uvs",shrinkToFit:o,usage:s.VERTEX|s.COPY_DST}),c=new a({data:u,label:"index-mesh-buffer",shrinkToFit:o,usage:s.INDEX|s.COPY_DST});super({attributes:{aPosition:{buffer:d,format:"float32x2",stride:8,offset:0},aUV:{buffer:l,format:"float32x2",stride:8,offset:0}},indexBuffer:c,topology:t.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(e){this.attributes.aPosition.buffer.data=e}get uvs(){return this.attributes.aUV.buffer.data}set uvs(e){this.attributes.aUV.buffer.data=e}get indices(){return this.indexBuffer.data}set indices(e){this.indexBuffer.data=e}};n.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let m=n;export{m as M};
