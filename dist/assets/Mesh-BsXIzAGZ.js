import{V as P,G as I,a as m,v as f,T}from"./index-DMlA-7KB.js";import{S as v}from"./State-3sV0XrC-.js";import{M as S}from"./MeshGeometry-CPXfurOR.js";function U(y,t,e,o,s,u,n,i){const r=n-e,h=i-o,d=s-e,a=u-o,g=y-e,l=t-o,_=r*r+h*h,c=r*d+h*a,x=r*g+h*l,p=d*d+a*a,b=d*g+a*l,w=1/(_*p-c*c),M=(p*x-c*b)*w,V=(_*b-c*x)*w;return M>=0&&V>=0&&M+V<1}class E extends P{constructor(...t){let e=t[0];e instanceof I&&(m(f,"Mesh: use new Mesh({ geometry, shader }) instead"),e={geometry:e,shader:t[1]},t[3]&&(m(f,"Mesh: drawMode argument has been removed, use geometry.topology instead"),e.geometry.topology=t[3]));const{geometry:o,shader:s,texture:u,roundPixels:n,state:i,...r}=e;super({label:"Mesh",...r}),this.renderPipeId="mesh",this._shader=null,this.allowChildren=!1,this.shader=s??null,this.texture=u??(s==null?void 0:s.texture)??T.WHITE,this.state=i??v.for2d(),this._geometry=o,this._geometry.on("update",this.onViewUpdate,this),this.roundPixels=n??!1}get material(){return m(f,"mesh.material property has been removed, use mesh.shader instead"),this._shader}set shader(t){this._shader!==t&&(this._shader=t,this.onViewUpdate())}get shader(){return this._shader}set geometry(t){var e;this._geometry!==t&&((e=this._geometry)==null||e.off("update",this.onViewUpdate,this),t.on("update",this.onViewUpdate,this),this._geometry=t,this.onViewUpdate())}get geometry(){return this._geometry}set texture(t){t||(t=T.EMPTY);const e=this._texture;e!==t&&(e&&e.dynamic&&e.off("update",this.onViewUpdate,this),t.dynamic&&t.on("update",this.onViewUpdate,this),this.shader&&(this.shader.texture=t),this._texture=t,this.onViewUpdate())}get texture(){return this._texture}get batched(){return this._shader||(this.state.data&12)!==0?!1:this._geometry instanceof S?this._geometry.batchMode==="auto"?this._geometry.positions.length/2<=100:this._geometry.batchMode==="batch":!1}get bounds(){return this._geometry.bounds}updateBounds(){this._bounds=this._geometry.bounds}containsPoint(t){const{x:e,y:o}=t;if(!this.bounds.containsPoint(e,o))return!1;const s=this.geometry.getBuffer("aPosition").data,u=this.geometry.topology==="triangle-strip"?3:1;if(this.geometry.getIndex()){const n=this.geometry.getIndex().data,i=n.length;for(let r=0;r+2<i;r+=u){const h=n[r]*2,d=n[r+1]*2,a=n[r+2]*2;if(U(e,o,s[h],s[h+1],s[d],s[d+1],s[a],s[a+1]))return!0}}else{const n=s.length/2;for(let i=0;i+2<n;i+=u){const r=i*2,h=(i+1)*2,d=(i+2)*2;if(U(e,o,s[r],s[r+1],s[h],s[h+1],s[d],s[d+1]))return!0}}return!1}destroy(t){var o;if(super.destroy(t),typeof t=="boolean"?t:t==null?void 0:t.texture){const s=typeof t=="boolean"?t:t==null?void 0:t.textureSource;this._texture.destroy(s)}(o=this._geometry)==null||o.off("update",this.onViewUpdate,this),this._texture=null,this._geometry=null,this._shader=null}}export{E as M};
