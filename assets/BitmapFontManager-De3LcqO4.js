import{f as O,C as M,g as I,T as A,l as $}from"./getCanvasFillStyle-Bhfzdggk.js";import{E as Y,a as v,v as B,T as b,l as H,R as X,I as N,C as U,m as k,w as D}from"./index-DDZL8cFr.js";import{C as L}from"./CanvasPool-AohZQnYu.js";class G extends Y{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return v(B,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return v(B,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return v(B,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return v(B,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return v(B,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners();for(const e in this.chars)this.chars[e].texture?.destroy();this.chars=null,t&&(this.pages.forEach(e=>e.texture.destroy(!0)),this.pages=null)}}const K=class R extends G{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const e={...R.defaultOptions,...t};this._textureSize=e.textureSize,this._mipmap=e.mipmap;const i=e.style.clone();e.overrideFill&&(i._fill.color=16777215,i._fill.alpha=1,i._fill.texture=b.WHITE,i._fill.fill=null),this.applyFillAsTint=e.overrideFill;const s=i.fontSize;i.fontSize=this.baseMeasurementFontSize;const n=O(i);e.overrideSize?i._stroke&&(i._stroke.width*=this.baseRenderedFontSize/s):i.fontSize=this.baseRenderedFontSize=s,this._style=i,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,e.textureStyle&&(this._textureStyle=e.textureStyle instanceof H?e.textureStyle:new H(e.textureStyle)),this.fontMetrics=M.measureFont(n),this.lineHeight=i.lineHeight||this.fontMetrics.fontSize||i.fontSize}ensureCharacters(t){const e=M.graphemeSegmenter(t).filter(g=>!this._currentChars.includes(g)).filter((g,h,l)=>l.indexOf(g)===h);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let i;this._currentPageIndex===-1?i=this._nextPage():i=this.pages[this._currentPageIndex];let{canvas:s,context:n}=i.canvasAndContext,r=i.texture.source;const a=this._style;let o=this._currentX,p=this._currentY,d=this._currentMaxCharHeight;const u=this.baseRenderedFontSize/this.baseMeasurementFontSize,w=this._padding*u;let x=!1;const S=s.width/this.resolution,m=s.height/this.resolution;for(let g=0;g<e.length;g++){const h=e[g],l=M.measureText(h,a,s,!1);l.lineHeight=l.height;const f=l.width*u,_=Math.ceil((a.fontStyle==="italic"?2:1)*f),W=l.height*u,z=_+w*2,y=W+w*2;if(x=!1,h!==`
`&&h!=="\r"&&h!=="	"&&h!==" "&&(x=!0,d=Math.ceil(Math.max(y,d))),o+z>S&&(p+=d,d=y,o=0,p+d>m)){r.update();const C=this._nextPage();s=C.canvasAndContext.canvas,n=C.canvasAndContext.context,r=C.texture.source,o=0,p=0,d=0}const F=f/u-(a.dropShadow?.distance??0)-(a._stroke?.width??0);if(this.chars[h]={id:h.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:F,kerning:{}},x){this._drawGlyph(n,l,o+w,p+w,u,a);const C=r.width*u,P=r.height*u,E=new X(o/C*r.width,p/P*r.height,z/C*r.width,y/P*r.height);this.chars[h].texture=new b({source:r,frame:E}),o+=Math.ceil(z)}}r.update(),this._currentX=o,this._currentY=p,this._currentMaxCharHeight=d,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return v(B,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const i=this._measureCache;for(let s=0;s<t.length;s++){const n=t[s];for(let r=0;r<this._currentChars.length;r++){const a=this._currentChars[r];let o=i[n];o||(o=i[n]=e.measureText(n).width);let p=i[a];p||(p=i[a]=e.measureText(a).width);let d=e.measureText(n+a).width,u=d-(o+p);u&&(this.chars[n].kerning[a]=u),d=e.measureText(n+a).width,u=d-(o+p),u&&(this.chars[a].kerning[n]=u)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=L.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const i=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),s=new b({source:new N({resource:e.canvas,resolution:i,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(s.source.style=this._textureStyle);const n={canvasAndContext:e,texture:s};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,i){e.fontSize=this.baseRenderedFontSize,t.scale(i,i),t.font=O(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const s=e._stroke,n=s?.width??0;if(s&&(t.lineWidth=n,t.lineJoin=s.join,t.miterLimit=s.miterLimit,t.strokeStyle=I(s,t)),e._fill&&(t.fillStyle=I(e._fill,t)),e.dropShadow){const r=e.dropShadow,a=U.shared.setValue(r.color).toArray(),o=r.blur*i,p=r.distance*i;t.shadowColor=`rgba(${a[0]*255},${a[1]*255},${a[2]*255},${r.alpha})`,t.shadowBlur=o,t.shadowOffsetX=Math.cos(r.angle)*p,t.shadowOffsetY=Math.sin(r.angle)*p}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,i,s,n,r){const a=e.text,o=e.fontProperties,d=(r._stroke?.width??0)*n,u=i+d/2,w=s-d/2,x=o.descent*n,S=e.lineHeight*n;let m=!1;r.stroke&&d&&(m=!0,t.strokeText(a,u,w+S-x));const{shadowBlur:g,shadowOffsetX:h,shadowOffsetY:l}=t;r._fill&&(m&&(t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0),t.fillText(a,u,w+S-x)),m&&(t.shadowBlur=g,t.shadowOffsetX=h,t.shadowOffsetY=l)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:i}=this.pages[t];L.returnCanvasAndContext(e),i.destroy(!0)}this.pages=null}};K.defaultOptions={textureSize:512,style:new A,mipmap:!0};let j=K;function q(c,t,e,i){const s={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};s.offsetY=e.baseLineOffset;let n=s.lines[0],r=null,a=!0;const o={width:0,start:0,index:0,positions:[],chars:[]},p=e.baseMeasurementFontSize/t.fontSize,d=t.letterSpacing*p,u=t.wordWrapWidth*p,w=t.lineHeight?t.lineHeight*p:e.lineHeight,x=t.wordWrap&&t.breakWords,S=h=>{const l=n.width;for(let f=0;f<o.index;f++){const _=h.positions[f];n.chars.push(h.chars[f]),n.charPositions.push(_+l)}n.width+=h.width,a=!1,o.width=0,o.index=0,o.chars.length=0},m=()=>{let h=n.chars.length-1;if(i){let l=n.chars[h];for(;l===" ";)n.width-=e.chars[l].xAdvance,l=n.chars[--h]}s.width=Math.max(s.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},a=!0,s.lines.push(n),s.height+=w},g=h=>h-d>u;for(let h=0;h<c.length+1;h++){let l;const f=h===c.length;f||(l=c[h]);const _=e.chars[l]||e.chars[" "];if(/(?:\s)/.test(l)||l==="\r"||l===`
`||f){if(!a&&t.wordWrap&&g(n.width+o.width)?(m(),S(o),f||n.charPositions.push(0)):(o.start=n.width,S(o),f||n.charPositions.push(0)),l==="\r"||l===`
`)m();else if(!f){const F=_.xAdvance+(_.kerning[r]||0)+d;n.width+=F,n.spaceWidth=F,n.spacesIndex.push(n.charPositions.length),n.chars.push(l)}}else{const y=_.kerning[r]||0,F=_.xAdvance+y+d;x&&g(n.width+o.width+F)&&(S(o),m()),o.positions[o.index++]=o.width+y,o.chars.push(l),o.width+=F}r=l}return m(),t.align==="center"?J(s):t.align==="right"?Z(s):t.align==="justify"&&V(s),s}function J(c){for(let t=0;t<c.lines.length;t++){const e=c.lines[t],i=c.width/2-e.width/2;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=i}}function Z(c){for(let t=0;t<c.lines.length;t++){const e=c.lines[t],i=c.width-e.width;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=i}}function V(c){const t=c.width;for(let e=0;e<c.lines.length;e++){const i=c.lines[e];let s=0,n=i.spacesIndex[s++],r=0;const a=i.spacesIndex.length,p=(t-i.width)/a;for(let d=0;d<i.charPositions.length;d++)d===n&&(n=i.spacesIndex[s++],r+=p),i.charPositions[d]+=r}}function Q(c){if(c==="")return[];typeof c=="string"&&(c=[c]);const t=[];for(let e=0,i=c.length;e<i;e++){const s=c[e];if(Array.isArray(s)){if(s.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);if(s[0].length===0||s[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=s[0].charCodeAt(0),r=s[1].charCodeAt(0);if(r<n)throw new Error("[BitmapFont]: Invalid character range.");for(let a=n,o=r;a<=o;a++)t.push(String.fromCharCode(a))}else t.push(...Array.from(s))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}let T=0;class ee{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=$(1e3)}getFont(t,e){let i=`${e.fontFamily}-bitmap`,s=!0;if(e._fill.fill&&!e._stroke?(i+=e._fill.fill.styleKey,s=!1):(e._stroke||e.dropShadow)&&(i=`${e.styleKey}-bitmap`,s=!1),!k.has(i)){const r=Object.create(e);r.lineHeight=0;const a=new j({style:r,overrideFill:s,overrideSize:!0,...this.defaultOptions});T++,T>50&&D("BitmapText",`You have dynamically created ${T} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),a.once("destroy",()=>{T--,k.remove(i)}),k.set(i,a)}const n=k.get(i);return n.ensureCharacters?.(t),n}getLayout(t,e,i=!0){const s=this.getFont(t,e),n=`${t}-${e.styleKey}-${i}`;if(this.measureCache.has(n))return this.measureCache.get(n);const r=M.graphemeSegmenter(t),a=q(r,e,s,i);return this.measureCache.set(n,a),a}measureText(t,e,i=!0){return this.getLayout(t,e,i)}install(...t){let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:t[2]?.chars,resolution:t[2]?.resolution,padding:t[2]?.padding,skipKerning:t[2]?.skipKerning},v(B,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const i=e?.name;if(!i)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const s=e.style,n=s instanceof A?s:new A(s),r=e.dynamicFill??this._canUseTintForStyle(n),a=new j({style:n,overrideFill:r,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1,textureStyle:e.textureStyle}),o=Q(e.chars);return a.ensureCharacters(o.join("")),k.set(`${i}-bitmap`,a),a.once("destroy",()=>k.remove(`${i}-bitmap`)),a}uninstall(t){const e=`${t}-bitmap`,i=k.get(e);i&&i.destroy()}_canUseTintForStyle(t){return!t._stroke&&(!t.dropShadow||t.dropShadow.color===0)&&!t._fill.fill&&t._fill.color===16777215}}const ne=new ee;export{G as A,ne as B,q as g};
