import{R as ne,T as S,D as g,a1 as _,y as f,a2 as v,a3 as re,w as y,a4 as E,a5 as Q,m as A,a6 as O,G as ie,I as Z,a7 as oe,a8 as T,z as k}from"./index-z_3bUTQL.js";import{A as ce,B as N}from"./BitmapFontManager-BPWCUObT.js";class Y extends ce{constructor(e,s){super();const{textures:a,data:n}=e;Object.keys(n.pages).forEach(o=>{const r=n.pages[parseInt(o,10)],i=a[r.id];this.pages.push({texture:i})}),Object.keys(n.chars).forEach(o=>{const r=n.chars[o],{frame:i,source:d}=a[r.page],c=new ne(r.x+i.x,r.y+i.y,r.width,r.height),l=new S({source:d,frame:c});this.chars[o]={id:o.codePointAt(0),xOffset:r.xOffset,yOffset:r.yOffset,xAdvance:r.xAdvance,kerning:r.kerning??{},texture:l}}),this.baseRenderedFontSize=n.fontSize,this.baseMeasurementFontSize=n.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:n.fontSize},this.baseLineOffset=n.baseLineOffset,this.lineHeight=n.lineHeight,this.fontFamily=n.fontFamily,this.distanceField=n.distanceField??{type:"none",range:0},this.url=s}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{texture:s}=this.pages[e];s.destroy(!0)}this.pages=null}static install(e){N.install(e)}static uninstall(e){N.uninstall(e)}}const C={test(t){return typeof t=="string"&&t.startsWith("info face=")},parse(t){const e=t.match(/^[a-z]+\s+.+$/gm),s={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const h in e){const p=e[h].match(/^[a-z]+/gm)[0],u=e[h].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),m={};for(const R in u){const I=u[R].split("="),P=I[0],L=I[1].replace(/"/gm,""),z=parseFloat(L),ae=isNaN(z)?L:z;m[P]=ae}s[p].push(m)}const a={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[n]=s.info,[o]=s.common,[r]=s.distanceField??[];r&&(a.distanceField={range:parseInt(r.distanceRange,10),type:r.fieldType}),a.fontSize=parseInt(n.size,10),a.fontFamily=n.face,a.lineHeight=parseInt(o.lineHeight,10);const i=s.page;for(let h=0;h<i.length;h++)a.pages.push({id:parseInt(i[h].id,10)||0,file:i[h].file});const d={};a.baseLineOffset=a.lineHeight-parseInt(o.base,10);const c=s.char;for(let h=0;h<c.length;h++){const p=c[h],u=parseInt(p.id,10);let m=p.letter??p.char??String.fromCharCode(u);m==="space"&&(m=" "),d[u]=m,a.chars[m]={id:u,page:parseInt(p.page,10)||0,x:parseInt(p.x,10),y:parseInt(p.y,10),width:parseInt(p.width,10),height:parseInt(p.height,10),xOffset:parseInt(p.xoffset,10),yOffset:parseInt(p.yoffset,10),xAdvance:parseInt(p.xadvance,10),kerning:{}}}const l=s.kerning||[];for(let h=0;h<l.length;h++){const p=parseInt(l[h].first,10),u=parseInt(l[h].second,10),m=parseInt(l[h].amount,10);a.chars[d[u]].kerning[d[p]]=m}return a}},$={test(t){const e=t;return typeof e!="string"&&"getElementsByTagName"in e&&e.getElementsByTagName("page").length&&e.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(t){const e={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},s=t.getElementsByTagName("info")[0],a=t.getElementsByTagName("common")[0],n=t.getElementsByTagName("distanceField")[0];n&&(e.distanceField={type:n.getAttribute("fieldType"),range:parseInt(n.getAttribute("distanceRange"),10)});const o=t.getElementsByTagName("page"),r=t.getElementsByTagName("char"),i=t.getElementsByTagName("kerning");e.fontSize=parseInt(s.getAttribute("size"),10),e.fontFamily=s.getAttribute("face"),e.lineHeight=parseInt(a.getAttribute("lineHeight"),10);for(let c=0;c<o.length;c++)e.pages.push({id:parseInt(o[c].getAttribute("id"),10)||0,file:o[c].getAttribute("file")});const d={};e.baseLineOffset=e.lineHeight-parseInt(a.getAttribute("base"),10);for(let c=0;c<r.length;c++){const l=r[c],h=parseInt(l.getAttribute("id"),10);let p=l.getAttribute("letter")??l.getAttribute("char")??String.fromCharCode(h);p==="space"&&(p=" "),d[h]=p,e.chars[p]={id:h,page:parseInt(l.getAttribute("page"),10)||0,x:parseInt(l.getAttribute("x"),10),y:parseInt(l.getAttribute("y"),10),width:parseInt(l.getAttribute("width"),10),height:parseInt(l.getAttribute("height"),10),xOffset:parseInt(l.getAttribute("xoffset"),10),yOffset:parseInt(l.getAttribute("yoffset"),10),xAdvance:parseInt(l.getAttribute("xadvance"),10),kerning:{}}}for(let c=0;c<i.length;c++){const l=parseInt(i[c].getAttribute("first"),10),h=parseInt(i[c].getAttribute("second"),10),p=parseInt(i[c].getAttribute("amount"),10);e.chars[d[h]].kerning[d[l]]=p}return e}},G={test(t){return typeof t=="string"&&t.includes("<font>")?$.test(g.get().parseXML(t)):!1},parse(t){return $.parse(g.get().parseXML(t))}},le=[".xml",".fnt"],de={extension:{type:f.CacheParser,name:"cacheBitmapFont"},test:t=>t instanceof Y,getCacheableAssets(t,e){const s={};return t.forEach(a=>{s[a]=e,s[`${a}-bitmap`]=e}),s[`${e.fontFamily}-bitmap`]=e,s}},he={extension:{type:f.LoadParser,priority:_.Normal},name:"loadBitmapFont",test(t){return le.includes(v.extname(t).toLowerCase())},async testParse(t){return C.test(t)||G.test(t)},async parse(t,e,s){const a=C.test(t)?C.parse(t):G.parse(t),{src:n}=e,{pages:o}=a,r=[],i=a.distanceField?{scaleMode:"linear",alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:!1,resolution:1}:{};for(let h=0;h<o.length;++h){const p=o[h].file;let u=v.join(v.dirname(n),p);u=re(u,n),r.push({src:u,data:i})}const d=await s.load(r),c=r.map(h=>d[h.src]);return new Y({data:a,textures:c},n)},async load(t,e){return await(await g.get().fetch(t)).text()},async unload(t,e,s){await Promise.all(t.pages.map(a=>s.unload(a.texture.source._sourceOrigin))),t.destroy()}};class pe{constructor(e,s=!1){this._loader=e,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=s}add(e){e.forEach(s=>{this._assetList.push(s)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const e=[],s=Math.min(this._assetList.length,this._maxConcurrent);for(let a=0;a<s;a++)e.push(this._assetList.pop());await this._loader.load(e),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(e){this._isActive!==e&&(this._isActive=e,e&&!this._isLoading&&this._next())}}const fe={extension:{type:f.CacheParser,name:"cacheTextureArray"},test:t=>Array.isArray(t)&&t.every(e=>e instanceof S),getCacheableAssets:(t,e)=>{const s={};return t.forEach(a=>{e.forEach((n,o)=>{s[a+(o===0?"":o+1)]=n})}),s}};async function J(t){if("Image"in globalThis)return new Promise(e=>{const s=new Image;s.onload=()=>{e(!0)},s.onerror=()=>{e(!1)},s.src=t});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const e=await(await fetch(t)).blob();await createImageBitmap(e)}catch{return!1}return!0}return!1}const ue={extension:{type:f.DetectionParser,priority:1},test:async()=>J("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async t=>[...t,"avif"],remove:async t=>t.filter(e=>e!=="avif")},V=["png","jpg","jpeg"],me={extension:{type:f.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async t=>[...t,...V],remove:async t=>t.filter(e=>!V.includes(e))},ge="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function j(t){return ge?!1:document.createElement("video").canPlayType(t)!==""}const Ae={extension:{type:f.DetectionParser,priority:0},test:async()=>j("video/mp4"),add:async t=>[...t,"mp4","m4v"],remove:async t=>t.filter(e=>e!=="mp4"&&e!=="m4v")},ye={extension:{type:f.DetectionParser,priority:0},test:async()=>j("video/ogg"),add:async t=>[...t,"ogv"],remove:async t=>t.filter(e=>e!=="ogv")},ve={extension:{type:f.DetectionParser,priority:0},test:async()=>j("video/webm"),add:async t=>[...t,"webm"],remove:async t=>t.filter(e=>e!=="webm")},be={extension:{type:f.DetectionParser,priority:0},test:async()=>J("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async t=>[...t,"webp"],remove:async t=>t.filter(e=>e!=="webp")};class we{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(e,s,a)=>(this._parsersValidated=!1,e[s]=a,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(e,s){const a={promise:null,parser:null};return a.promise=(async()=>{var r,i;let n=null,o=null;if(s.loadParser&&(o=this._parserHash[s.loadParser],o||y(`[Assets] specified load parser "${s.loadParser}" not found while loading ${e}`)),!o){for(let d=0;d<this.parsers.length;d++){const c=this.parsers[d];if(c.load&&((r=c.test)!=null&&r.call(c,e,s,this))){o=c;break}}if(!o)return y(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}n=await o.load(e,s,this),a.parser=o;for(let d=0;d<this.parsers.length;d++){const c=this.parsers[d];c.parse&&c.parse&&await((i=c.testParse)==null?void 0:i.call(c,n,s,this))&&(n=await c.parse(n,s,this)||n,a.parser=c)}return n})(),a}async load(e,s){this._parsersValidated||this._validateParsers();let a=0;const n={},o=Q(e),r=E(e,c=>({alias:[c],src:c,data:{}})),i=r.length,d=r.map(async c=>{const l=v.toAbsolute(c.src);if(!n[c.src])try{this.promiseCache[l]||(this.promiseCache[l]=this._getLoadPromiseAndParser(l,c)),n[c.src]=await this.promiseCache[l].promise,s&&s(++a/i)}catch(h){throw delete this.promiseCache[l],delete n[c.src],new Error(`[Loader.load] Failed to load ${l}.
${h}`)}});return await Promise.all(d),o?n[r[0].src]:n}async unload(e){const a=E(e,n=>({alias:[n],src:n})).map(async n=>{var i,d;const o=v.toAbsolute(n.src),r=this.promiseCache[o];if(r){const c=await r.promise;delete this.promiseCache[o],await((d=(i=r.parser)==null?void 0:i.unload)==null?void 0:d.call(i,c,n,this))}});await Promise.all(a)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(e=>e.name).reduce((e,s)=>(s.name?e[s.name]&&y(`[Assets] loadParser name conflict "${s.name}"`):y("[Assets] loadParser should have a name"),{...e,[s.name]:s}),{})}}function x(t,e){if(Array.isArray(e)){for(const s of e)if(t.startsWith(`data:${s}`))return!0;return!1}return t.startsWith(`data:${e}`)}function B(t,e){const s=t.split("?")[0],a=v.extname(s).toLowerCase();return Array.isArray(e)?e.includes(a):a===e}const _e=".json",xe="application/json",Be={extension:{type:f.LoadParser,priority:_.Low},name:"loadJson",test(t){return x(t,xe)||B(t,_e)},async load(t){return await(await g.get().fetch(t)).json()}},Ie=".txt",Le="text/plain",Ee={name:"loadTxt",extension:{type:f.LoadParser,priority:_.Low,name:"loadTxt"},test(t){return x(t,Le)||B(t,Ie)},async load(t){return await(await g.get().fetch(t)).text()}},ke=["normal","bold","100","200","300","400","500","600","700","800","900"],Pe=[".ttf",".otf",".woff",".woff2"],Fe=["font/ttf","font/otf","font/woff","font/woff2"],Oe=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function Re(t){const e=v.extname(t),n=v.basename(t,e).replace(/(-|_)/g," ").toLowerCase().split(" ").map(i=>i.charAt(0).toUpperCase()+i.slice(1));let o=n.length>0;for(const i of n)if(!i.match(Oe)){o=!1;break}let r=n.join(" ");return o||(r=`"${r.replace(/[\\"]/g,"\\$&")}"`),r}const Te=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function Ce(t){return Te.test(t)?t:encodeURI(t)}const We={extension:{type:f.LoadParser,priority:_.Low},name:"loadWebFont",test(t){return x(t,Fe)||B(t,Pe)},async load(t,e){var a,n,o;const s=g.get().getFontFaceSet();if(s){const r=[],i=((a=e.data)==null?void 0:a.family)??Re(t),d=((o=(n=e.data)==null?void 0:n.weights)==null?void 0:o.filter(l=>ke.includes(l)))??["normal"],c=e.data??{};for(let l=0;l<d.length;l++){const h=d[l],p=new FontFace(i,`url(${Ce(t)})`,{...c,weight:h});await p.load(),s.add(p),r.push(p)}return A.set(`${i}-and-url`,{url:t,fontFaces:r}),r.length===1?r[0]:r}return y("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(t){(Array.isArray(t)?t:[t]).forEach(e=>{A.remove(`${e.family}-and-url`),g.get().getFontFaceSet().delete(e)})}};function U(t,e=1){var a;const s=(a=O.RETINA_PREFIX)==null?void 0:a.exec(t);return s?parseFloat(s[1]):e}function D(t,e,s){t.label=s,t._sourceOrigin=s;const a=new S({source:t,label:s}),n=()=>{delete e.promiseCache[s],A.has(s)&&A.remove(s)};return a.source.once("destroy",()=>{e.promiseCache[s]&&(y("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."),n())}),a.once("destroy",()=>{t.destroyed||(y("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),n())}),a}const Me=".svg",Se="image/svg+xml",je={extension:{type:f.LoadParser,priority:_.Low,name:"loadSVG"},name:"loadSVG",config:{crossOrigin:"anonymous",parseAsGraphicsContext:!1},test(t){return x(t,Se)||B(t,Me)},async load(t,e,s){var a;return((a=e.data)==null?void 0:a.parseAsGraphicsContext)??this.config.parseAsGraphicsContext?De(t):Ue(t,e,s,this.config.crossOrigin)},unload(t){t.destroy(!0)}};async function Ue(t,e,s,a){var I,P,L;const o=await(await g.get().fetch(t)).blob(),r=URL.createObjectURL(o),i=new Image;i.src=r,i.crossOrigin=a,await i.decode(),URL.revokeObjectURL(r);const d=document.createElement("canvas"),c=d.getContext("2d"),l=((I=e.data)==null?void 0:I.resolution)||U(t),h=((P=e.data)==null?void 0:P.width)??i.width,p=((L=e.data)==null?void 0:L.height)??i.height;d.width=h*l,d.height=p*l,c.drawImage(i,0,0,h*l,p*l);const{parseAsGraphicsContext:u,...m}=e.data??{},R=new Z({resource:d,alphaMode:"premultiply-alpha-on-upload",resolution:l,...m});return D(R,s,t)}async function De(t){const s=await(await g.get().fetch(t)).text(),a=new ie;return a.svg(s),a}const ze=`(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;let b=null,M=class{constructor(){b||(b=URL.createObjectURL(new Blob([ze],{type:"application/javascript"}))),this.worker=new Worker(b)}};M.revokeObjectURL=function(){b&&(URL.revokeObjectURL(b),b=null)};const Ne=`(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;let w=null;class q{constructor(){w||(w=URL.createObjectURL(new Blob([Ne],{type:"application/javascript"}))),this.worker=new Worker(w)}}q.revokeObjectURL=function(){w&&(URL.revokeObjectURL(w),w=null)};let H=0,W;class $e{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(e=>{const{worker:s}=new M;s.addEventListener("message",a=>{s.terminate(),M.revokeObjectURL(),e(a.data)})}),this._isImageBitmapSupported)}loadImageBitmap(e,s){var a;return this._run("loadImageBitmap",[e,(a=s==null?void 0:s.data)==null?void 0:a.alphaMode])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){W===void 0&&(W=navigator.hardwareConcurrency||4);let e=this._workerPool.pop();return!e&&this._createdWorkers<W&&(this._createdWorkers++,e=new q().worker,e.addEventListener("message",s=>{this._complete(s.data),this._returnWorker(s.target),this._next()})),e}_returnWorker(e){this._workerPool.push(e)}_complete(e){e.error!==void 0?this._resolveHash[e.uuid].reject(e.error):this._resolveHash[e.uuid].resolve(e.data),this._resolveHash[e.uuid]=null}async _run(e,s){await this._initWorkers();const a=new Promise((n,o)=>{this._queue.push({id:e,arguments:s,resolve:n,reject:o})});return this._next(),a}_next(){if(!this._queue.length)return;const e=this._getWorker();if(!e)return;const s=this._queue.pop(),a=s.id;this._resolveHash[H]={resolve:s.resolve,reject:s.reject},e.postMessage({data:s.arguments,uuid:H++,id:a})}}const X=new $e,Ge=[".jpeg",".jpg",".png",".webp",".avif"],Ve=["image/jpeg","image/png","image/webp","image/avif"];async function He(t,e){var n;const s=await g.get().fetch(t);if(!s.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${s.status} ${s.statusText}`);const a=await s.blob();return((n=e==null?void 0:e.data)==null?void 0:n.alphaMode)==="premultiplied-alpha"?createImageBitmap(a,{premultiplyAlpha:"none"}):createImageBitmap(a)}const ee={name:"loadTextures",extension:{type:f.LoadParser,priority:_.High,name:"loadTextures"},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(t){return x(t,Ve)||B(t,Ge)},async load(t,e,s){var o;let a=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await X.isImageBitmapSupported()?a=await X.loadImageBitmap(t,e):a=await He(t,e):a=await new Promise((r,i)=>{a=new Image,a.crossOrigin=this.config.crossOrigin,a.src=t,a.complete?r(a):(a.onload=()=>{r(a)},a.onerror=i)});const n=new Z({resource:a,alphaMode:"premultiply-alpha-on-upload",resolution:((o=e.data)==null?void 0:o.resolution)||U(t),...e.data});return D(n,s,t)},unload(t){t.destroy(!0)}},te=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"],Xe=te.map(t=>`video/${t.substring(1)}`);function Ke(t,e,s){s===void 0&&!e.startsWith("data:")?t.crossOrigin=Ze(e):s!==!1&&(t.crossOrigin=typeof s=="string"?s:"anonymous")}function Qe(t){return new Promise((e,s)=>{t.addEventListener("canplaythrough",a),t.addEventListener("error",n),t.load();function a(){o(),e()}function n(r){o(),s(r)}function o(){t.removeEventListener("canplaythrough",a),t.removeEventListener("error",n)}})}function Ze(t,e=globalThis.location){if(t.startsWith("data:"))return"";e||(e=globalThis.location);const s=new URL(t,document.baseURI);return s.hostname!==e.hostname||s.port!==e.port||s.protocol!==e.protocol?"anonymous":""}const Ye={name:"loadVideo",extension:{type:f.LoadParser,name:"loadVideo"},test(t){const e=x(t,Xe),s=B(t,te);return e||s},async load(t,e,s){var d,c;const a={...T.defaultOptions,resolution:((d=e.data)==null?void 0:d.resolution)||U(t),alphaMode:((c=e.data)==null?void 0:c.alphaMode)||await oe(),...e.data},n=document.createElement("video"),o={preload:a.autoLoad!==!1?"auto":void 0,"webkit-playsinline":a.playsinline!==!1?"":void 0,playsinline:a.playsinline!==!1?"":void 0,muted:a.muted===!0?"":void 0,loop:a.loop===!0?"":void 0,autoplay:a.autoPlay!==!1?"":void 0};Object.keys(o).forEach(l=>{const h=o[l];h!==void 0&&n.setAttribute(l,h)}),a.muted===!0&&(n.muted=!0),Ke(n,t,a.crossorigin);const r=document.createElement("source");let i;if(t.startsWith("data:"))i=t.slice(5,t.indexOf(";"));else if(!t.startsWith("blob:")){const l=t.split("?")[0].slice(t.lastIndexOf(".")+1).toLowerCase();i=T.MIME_TYPES[l]||`video/${l}`}return r.src=t,i&&(r.type=i),new Promise(l=>{const h=async()=>{const p=new T({...a,resource:n});n.removeEventListener("canplay",h),e.data.preload&&await Qe(n),l(D(p,s,t))};n.addEventListener("canplay",h),n.appendChild(r)})},unload(t){t.destroy(!0)}},se={extension:{type:f.ResolveParser,name:"resolveTexture"},test:ee.test,parse:t=>{var e;return{resolution:parseFloat(((e=O.RETINA_PREFIX.exec(t))==null?void 0:e[1])??"1"),format:t.split(".").pop(),src:t}}},Je={extension:{type:f.ResolveParser,priority:-2,name:"resolveJson"},test:t=>O.RETINA_PREFIX.test(t)&&t.endsWith(".json"),parse:se.parse};class qe{constructor(){this._detections=[],this._initialized=!1,this.resolver=new O,this.loader=new we,this.cache=A,this._backgroundLoader=new pe(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(e={}){var o,r;if(this._initialized){y("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}if(this._initialized=!0,e.defaultSearchParams&&this.resolver.setDefaultSearchParams(e.defaultSearchParams),e.basePath&&(this.resolver.basePath=e.basePath),e.bundleIdentifier&&this.resolver.setBundleIdentifier(e.bundleIdentifier),e.manifest){let i=e.manifest;typeof i=="string"&&(i=await this.load(i)),this.resolver.addManifest(i)}const s=((o=e.texturePreference)==null?void 0:o.resolution)??1,a=typeof s=="number"?[s]:s,n=await this._detectFormats({preferredFormats:(r=e.texturePreference)==null?void 0:r.format,skipDetections:e.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:n,resolution:a}}),e.preferences&&this.setPreferences(e.preferences)}add(e){this.resolver.add(e)}async load(e,s){this._initialized||await this.init();const a=Q(e),n=E(e).map(i=>{if(typeof i!="string"){const d=this.resolver.getAlias(i);return d.some(c=>!this.resolver.hasKey(c))&&this.add(i),Array.isArray(d)?d[0]:d}return this.resolver.hasKey(i)||this.add({alias:i,src:i}),i}),o=this.resolver.resolve(n),r=await this._mapLoadToResolve(o,s);return a?r[n[0]]:r}addBundle(e,s){this.resolver.addBundle(e,s)}async loadBundle(e,s){this._initialized||await this.init();let a=!1;typeof e=="string"&&(a=!0,e=[e]);const n=this.resolver.resolveBundle(e),o={},r=Object.keys(n);let i=0,d=0;const c=()=>{s==null||s(++i/d)},l=r.map(h=>{const p=n[h];return d+=Object.keys(p).length,this._mapLoadToResolve(p,c).then(u=>{o[h]=u})});return await Promise.all(l),a?o[e[0]]:o}async backgroundLoad(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const s=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(s))}async backgroundLoadBundle(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const s=this.resolver.resolveBundle(e);Object.values(s).forEach(a=>{this._backgroundLoader.add(Object.values(a))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(e){if(typeof e=="string")return A.get(e);const s={};for(let a=0;a<e.length;a++)s[a]=A.get(e[a]);return s}async _mapLoadToResolve(e,s){const a=[...new Set(Object.values(e))];this._backgroundLoader.active=!1;const n=await this.loader.load(a,s);this._backgroundLoader.active=!0;const o={};return a.forEach(r=>{const i=n[r.src],d=[r.src];r.alias&&d.push(...r.alias),d.forEach(c=>{o[c]=i}),A.set(d,i)}),o}async unload(e){this._initialized||await this.init();const s=E(e).map(n=>typeof n!="string"?n.src:n),a=this.resolver.resolve(s);await this._unloadFromResolved(a)}async unloadBundle(e){this._initialized||await this.init(),e=E(e);const s=this.resolver.resolveBundle(e),a=Object.keys(s).map(n=>this._unloadFromResolved(s[n]));await Promise.all(a)}async _unloadFromResolved(e){const s=Object.values(e);s.forEach(a=>{A.remove(a.src)}),await this.loader.unload(s)}async _detectFormats(e){let s=[];e.preferredFormats&&(s=Array.isArray(e.preferredFormats)?e.preferredFormats:[e.preferredFormats]);for(const a of e.detections)e.skipDetections||await a.test()?s=await a.add(s):e.skipDetections||(s=await a.remove(s));return s=s.filter((a,n)=>s.indexOf(a)===n),s}get detections(){return this._detections}setPreferences(e){this.loader.parsers.forEach(s=>{s.config&&Object.keys(s.config).filter(a=>a in e).forEach(a=>{s.config[a]=e[a]})})}}const F=new qe;k.handleByList(f.LoadParser,F.loader.parsers).handleByList(f.ResolveParser,F.resolver.parsers).handleByList(f.CacheParser,F.cache.parsers).handleByList(f.DetectionParser,F.detections);k.add(fe,me,ue,be,Ae,ye,ve,Be,Ee,We,je,ee,Ye,he,de,se,Je);const K={loader:f.LoadParser,resolver:f.ResolveParser,cache:f.CacheParser,detection:f.DetectionParser};k.handle(f.Asset,t=>{const e=t.ref;Object.entries(K).filter(([s])=>!!e[s]).forEach(([s,a])=>k.add(Object.assign(e[s],{extension:e[s].extension??a})))},t=>{const e=t.ref;Object.keys(K).filter(s=>!!e[s]).forEach(s=>k.remove(e[s]))});export{F as A};
