import{a3 as ce,R as G,T as z,D as A,a4 as I,J as f,a5 as b,a6 as le,w,a7 as P,a8 as q,l as y,a9 as C,c as de,I as ee,aa as he,ab as R,K as k}from"./index-C9klQOEH.js";import{A as pe,B as H}from"./BitmapFontManager-BRuJYlAf.js";class te extends pe{constructor(e,t){super();const{textures:a,data:r}=e;Object.keys(r.pages).forEach(n=>{const i=r.pages[parseInt(n,10)],o=a[i.id];this.pages.push({texture:o})}),Object.keys(r.chars).forEach(n=>{const i=r.chars[n],{frame:o,source:d,rotate:l}=a[i.page],p=ce.transformRectCoords(i,o,l,new G),c=new z({frame:p,orig:new G(0,0,i.width,i.height),source:d,rotate:l});this.chars[n]={id:n.codePointAt(0),xOffset:i.xOffset,yOffset:i.yOffset,xAdvance:i.xAdvance,kerning:i.kerning??{},texture:c}}),this.baseRenderedFontSize=r.fontSize,this.baseMeasurementFontSize=r.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:r.fontSize},this.baseLineOffset=r.baseLineOffset,this.lineHeight=r.lineHeight,this.fontFamily=r.fontFamily,this.distanceField=r.distanceField??{type:"none",range:0},this.url=t}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{texture:t}=this.pages[e];t.destroy(!0)}this.pages=null}static install(e){H.install(e)}static uninstall(e){H.uninstall(e)}}const S={test(s){return typeof s=="string"&&s.startsWith("info face=")},parse(s){const e=s.match(/^[a-z]+\s+.+$/gm),t={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const c in e){const h=e[c].match(/^[a-z]+/gm)[0],u=e[c].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),g={};for(const m in u){const v=u[m].split("="),x=v[0],O=v[1].replace(/"/gm,""),N=parseFloat(O),oe=isNaN(N)?O:N;g[x]=oe}t[h].push(g)}const a={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[r]=t.info,[n]=t.common,[i]=t.distanceField??[];i&&(a.distanceField={range:parseInt(i.distanceRange,10),type:i.fieldType}),a.fontSize=parseInt(r.size,10),a.fontFamily=r.face,a.lineHeight=parseInt(n.lineHeight,10);const o=t.page;for(let c=0;c<o.length;c++)a.pages.push({id:parseInt(o[c].id,10)||0,file:o[c].file});const d={};a.baseLineOffset=a.lineHeight-parseInt(n.base,10);const l=t.char;for(let c=0;c<l.length;c++){const h=l[c],u=parseInt(h.id,10);let g=h.letter??h.char??String.fromCharCode(u);g==="space"&&(g=" "),d[u]=g,a.chars[g]={id:u,page:parseInt(h.page,10)||0,x:parseInt(h.x,10),y:parseInt(h.y,10),width:parseInt(h.width,10),height:parseInt(h.height,10),xOffset:parseInt(h.xoffset,10),yOffset:parseInt(h.yoffset,10),xAdvance:parseInt(h.xadvance,10),kerning:{}}}const p=t.kerning||[];for(let c=0;c<p.length;c++){const h=parseInt(p[c].first,10),u=parseInt(p[c].second,10),g=parseInt(p[c].amount,10);a.chars[d[u]].kerning[d[h]]=g}return a}},X={test(s){const e=s;return typeof e!="string"&&"getElementsByTagName"in e&&e.getElementsByTagName("page").length&&e.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(s){const e={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},t=s.getElementsByTagName("info")[0],a=s.getElementsByTagName("common")[0],r=s.getElementsByTagName("distanceField")[0];r&&(e.distanceField={type:r.getAttribute("fieldType"),range:parseInt(r.getAttribute("distanceRange"),10)});const n=s.getElementsByTagName("page"),i=s.getElementsByTagName("char"),o=s.getElementsByTagName("kerning");e.fontSize=parseInt(t.getAttribute("size"),10),e.fontFamily=t.getAttribute("face"),e.lineHeight=parseInt(a.getAttribute("lineHeight"),10);for(let l=0;l<n.length;l++)e.pages.push({id:parseInt(n[l].getAttribute("id"),10)||0,file:n[l].getAttribute("file")});const d={};e.baseLineOffset=e.lineHeight-parseInt(a.getAttribute("base"),10);for(let l=0;l<i.length;l++){const p=i[l],c=parseInt(p.getAttribute("id"),10);let h=p.getAttribute("letter")??p.getAttribute("char")??String.fromCharCode(c);h==="space"&&(h=" "),d[c]=h,e.chars[h]={id:c,page:parseInt(p.getAttribute("page"),10)||0,x:parseInt(p.getAttribute("x"),10),y:parseInt(p.getAttribute("y"),10),width:parseInt(p.getAttribute("width"),10),height:parseInt(p.getAttribute("height"),10),xOffset:parseInt(p.getAttribute("xoffset"),10),yOffset:parseInt(p.getAttribute("yoffset"),10),xAdvance:parseInt(p.getAttribute("xadvance"),10),kerning:{}}}for(let l=0;l<o.length;l++){const p=parseInt(o[l].getAttribute("first"),10),c=parseInt(o[l].getAttribute("second"),10),h=parseInt(o[l].getAttribute("amount"),10);e.chars[d[c]].kerning[d[p]]=h}return e}},K={test(s){return typeof s=="string"&&s.match(/<font(\s|>)/)?X.test(A.get().parseXML(s)):!1},parse(s){return X.parse(A.get().parseXML(s))}},fe=[".xml",".fnt"],ue={extension:{type:f.CacheParser,name:"cacheBitmapFont"},test:s=>s instanceof te,getCacheableAssets(s,e){const t={};return s.forEach(a=>{t[a]=e,t[`${a}-bitmap`]=e}),t[`${e.fontFamily}-bitmap`]=e,t}},ge={extension:{type:f.LoadParser,priority:I.Normal},name:"loadBitmapFont",id:"bitmap-font",test(s){return fe.includes(b.extname(s).toLowerCase())},async testParse(s){return S.test(s)||K.test(s)},async parse(s,e,t){const a=S.test(s)?S.parse(s):K.parse(s),{src:r}=e,{pages:n}=a,i=[],o=a.distanceField?{scaleMode:"linear",alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:!1,resolution:1}:{};for(let c=0;c<n.length;++c){const h=n[c].file;let u=b.join(b.dirname(r),h);u=le(u,r),i.push({src:u,data:o})}const d=await t.load(i),l=i.map(c=>d[c.src]);return new te({data:a,textures:l},r)},async load(s,e){return await(await A.get().fetch(s)).text()},async unload(s,e,t){await Promise.all(s.pages.map(a=>t.unload(a.texture.source._sourceOrigin))),s.destroy()}};class me{constructor(e,t=!1){this._loader=e,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=t}add(e){e.forEach(t=>{this._assetList.push(t)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const e=[],t=Math.min(this._assetList.length,this._maxConcurrent);for(let a=0;a<t;a++)e.push(this._assetList.pop());await this._loader.load(e),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(e){this._isActive!==e&&(this._isActive=e,e&&!this._isLoading&&this._next())}}const Ae={extension:{type:f.CacheParser,name:"cacheTextureArray"},test:s=>Array.isArray(s)&&s.every(e=>e instanceof z),getCacheableAssets:(s,e)=>{const t={};return s.forEach(a=>{e.forEach((r,n)=>{t[a+(n===0?"":n+1)]=r})}),t}};async function se(s){if("Image"in globalThis)return new Promise(e=>{const t=new Image;t.onload=()=>{e(!0)},t.onerror=()=>{e(!1)},t.src=s});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const e=await(await fetch(s)).blob();await createImageBitmap(e)}catch{return!1}return!0}return!1}const ye={extension:{type:f.DetectionParser,priority:1},test:async()=>se("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async s=>[...s,"avif"],remove:async s=>s.filter(e=>e!=="avif")},Q=["png","jpg","jpeg"],ve={extension:{type:f.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async s=>[...s,...Q],remove:async s=>s.filter(e=>!Q.includes(e))},we="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function M(s){return we?!1:document.createElement("video").canPlayType(s)!==""}const be={extension:{type:f.DetectionParser,priority:0},test:async()=>M("video/mp4"),add:async s=>[...s,"mp4","m4v"],remove:async s=>s.filter(e=>e!=="mp4"&&e!=="m4v")},xe={extension:{type:f.DetectionParser,priority:0},test:async()=>M("video/ogg"),add:async s=>[...s,"ogv"],remove:async s=>s.filter(e=>e!=="ogv")},_e={extension:{type:f.DetectionParser,priority:0},test:async()=>M("video/webm"),add:async s=>[...s,"webm"],remove:async s=>s.filter(e=>e!=="webm")},Ee={extension:{type:f.DetectionParser,priority:0},test:async()=>se("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async s=>[...s,"webp"],remove:async s=>s.filter(e=>e!=="webp")},ae=class T{constructor(){this.loadOptions={...T.defaultOptions},this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(e,t,a)=>(this._parsersValidated=!1,e[t]=a,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(e,t){const a={promise:null,parser:null};return a.promise=(async()=>{let r=null,n=null;if((t.parser||t.loadParser)&&(n=this._parserHash[t.parser||t.loadParser],t.loadParser&&w(`[Assets] "loadParser" is deprecated, use "parser" instead for ${e}`),n||w(`[Assets] specified load parser "${t.parser||t.loadParser}" not found while loading ${e}`)),!n){for(let i=0;i<this.parsers.length;i++){const o=this.parsers[i];if(o.load&&o.test?.(e,t,this)){n=o;break}}if(!n)return w(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}r=await n.load(e,t,this),a.parser=n;for(let i=0;i<this.parsers.length;i++){const o=this.parsers[i];o.parse&&o.parse&&await o.testParse?.(r,t,this)&&(r=await o.parse(r,t,this)||r,a.parser=o)}return r})(),a}async load(e,t){this._parsersValidated||this._validateParsers();const a=typeof t=="function"?{...T.defaultOptions,...this.loadOptions,onProgress:t}:{...T.defaultOptions,...this.loadOptions,...t||{}},{onProgress:r,onError:n,strategy:i,retryCount:o,retryDelay:d}=a;let l=0;const p={},c=q(e),h=P(e,m=>({alias:[m],src:m,data:{}})),u=h.reduce((m,v)=>m+(v.progressSize||1),0),g=h.map(async m=>{const v=b.toAbsolute(m.src);p[m.src]||(await this._loadAssetWithRetry(v,m,{onProgress:r,onError:n,strategy:i,retryCount:o,retryDelay:d},p),l+=m.progressSize||1,r&&r(l/u))});return await Promise.all(g),c?p[h[0].src]:p}async unload(e){const a=P(e,r=>({alias:[r],src:r})).map(async r=>{const n=b.toAbsolute(r.src),i=this.promiseCache[n];if(i){const o=await i.promise;delete this.promiseCache[n],await i.parser?.unload?.(o,r,this)}});await Promise.all(a)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(e=>e.name||e.id).reduce((e,t)=>(!t.name&&!t.id?w("[Assets] parser should have an id"):(e[t.name]||e[t.id])&&w(`[Assets] parser id conflict "${t.id}"`),e[t.name]=t,t.id&&(e[t.id]=t),e),{})}async _loadAssetWithRetry(e,t,a,r){let n=0;const{onError:i,strategy:o,retryCount:d,retryDelay:l}=a,p=c=>new Promise(h=>setTimeout(h,c));for(;;)try{this.promiseCache[e]||(this.promiseCache[e]=this._getLoadPromiseAndParser(e,t)),r[t.src]=await this.promiseCache[e].promise;return}catch(c){delete this.promiseCache[e],delete r[t.src],n++;const h=o!=="retry"||n>d;if(o==="retry"&&!h){i&&i(c,t),await p(l);continue}if(o==="skip"){i&&i(c,t);return}throw i&&i(c,t),new Error(`[Loader.load] Failed to load ${e}.
${c}`)}}};ae.defaultOptions={onProgress:void 0,onError:void 0,strategy:"throw",retryCount:3,retryDelay:250};let Ie=ae;function B(s,e){if(Array.isArray(e)){for(const t of e)if(s.startsWith(`data:${t}`))return!0;return!1}return s.startsWith(`data:${e}`)}function L(s,e){const t=s.split("?")[0],a=b.extname(t).toLowerCase();return Array.isArray(e)?e.includes(a):a===e}const Be=".json",Le="application/json",Pe={extension:{type:f.LoadParser,priority:I.Low},name:"loadJson",id:"json",test(s){return B(s,Le)||L(s,Be)},async load(s){return await(await A.get().fetch(s)).json()}},ke=".txt",Oe="text/plain",Fe={name:"loadTxt",id:"text",extension:{type:f.LoadParser,priority:I.Low,name:"loadTxt"},test(s){return B(s,Oe)||L(s,ke)},async load(s){return await(await A.get().fetch(s)).text()}},Re=["normal","bold","100","200","300","400","500","600","700","800","900"],Te=[".ttf",".otf",".woff",".woff2"],Ce=["font/ttf","font/otf","font/woff","font/woff2"],Me=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function Se(s){const e=b.extname(s),r=b.basename(s,e).replace(/(-|_)/g," ").toLowerCase().split(" ").map(o=>o.charAt(0).toUpperCase()+o.slice(1));let n=r.length>0;for(const o of r)if(!o.match(Me)){n=!1;break}let i=r.join(" ");return n||(i=`"${i.replace(/[\\"]/g,"\\$&")}"`),i}const We=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function je(s){return We.test(s)?s:encodeURI(s)}const Ue={extension:{type:f.LoadParser,priority:I.Low},name:"loadWebFont",id:"web-font",test(s){return B(s,Ce)||L(s,Te)},async load(s,e){const t=A.get().getFontFaceSet();if(t){const a=[],r=e.data?.family??Se(s),n=e.data?.weights?.filter(o=>Re.includes(o))??["normal"],i=e.data??{};for(let o=0;o<n.length;o++){const d=n[o],l=new FontFace(r,`url(${je(s)})`,{...i,weight:d});await l.load(),t.add(l),a.push(l)}return y.has(`${r}-and-url`)?y.get(`${r}-and-url`).entries.push({url:s,faces:a}):y.set(`${r}-and-url`,{entries:[{url:s,faces:a}]}),a.length===1?a[0]:a}return w("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(s){const e=Array.isArray(s)?s:[s],t=e[0].family,a=y.get(`${t}-and-url`),r=a.entries.find(n=>n.faces.some(i=>e.indexOf(i)!==-1));r.faces=r.faces.filter(n=>e.indexOf(n)===-1),r.faces.length===0&&(a.entries=a.entries.filter(n=>n!==r)),e.forEach(n=>{A.get().getFontFaceSet().delete(n)}),a.entries.length===0&&y.remove(`${t}-and-url`)}};function $(s,e=1){const t=C.RETINA_PREFIX?.exec(s);return t?parseFloat(t[1]):e}function V(s,e,t){s.label=t,s._sourceOrigin=t;const a=new z({source:s,label:t}),r=()=>{delete e.promiseCache[t],y.has(t)&&y.remove(t)};return a.source.once("destroy",()=>{e.promiseCache[t]&&(w("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."),r())}),a.once("destroy",()=>{s.destroyed||(w("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),r())}),a}const De=".svg",ze="image/svg+xml",$e={extension:{type:f.LoadParser,priority:I.Low,name:"loadSVG"},name:"loadSVG",id:"svg",config:{crossOrigin:"anonymous",parseAsGraphicsContext:!1},test(s){return B(s,ze)||L(s,De)},async load(s,e,t){return e.data?.parseAsGraphicsContext??this.config.parseAsGraphicsContext?Ne(s):Ve(s,e,t,this.config.crossOrigin)},unload(s){s.destroy(!0)}};async function Ve(s,e,t,a){const r=await A.get().fetch(s),n=A.get().createImage();n.src=`data:image/svg+xml;charset=utf-8,${encodeURIComponent(await r.text())}`,n.crossOrigin=a,await n.decode();const i=e.data?.width??n.width,o=e.data?.height??n.height,d=e.data?.resolution||$(s),l=Math.ceil(i*d),p=Math.ceil(o*d),c=A.get().createCanvas(l,p),h=c.getContext("2d");h.imageSmoothingEnabled=!0,h.imageSmoothingQuality="high",h.drawImage(n,0,0,i*d,o*d);const{parseAsGraphicsContext:u,...g}=e.data??{},m=new ee({resource:c,alphaMode:"premultiply-alpha-on-upload",resolution:d,...g});return V(m,t,s)}async function Ne(s){const t=await(await A.get().fetch(s)).text(),a=new de;return a.svg(t),a}const Ge=`(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;let _=null,D=class{constructor(){_||(_=URL.createObjectURL(new Blob([Ge],{type:"application/javascript"}))),this.worker=new Worker(_)}};D.revokeObjectURL=function(){_&&(URL.revokeObjectURL(_),_=null)};const He=`(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;let E=null;class re{constructor(){E||(E=URL.createObjectURL(new Blob([He],{type:"application/javascript"}))),this.worker=new Worker(E)}}re.revokeObjectURL=function(){E&&(URL.revokeObjectURL(E),E=null)};let Y=0,W;class Xe{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(e=>{const{worker:t}=new D;t.addEventListener("message",a=>{t.terminate(),D.revokeObjectURL(),e(a.data)})}),this._isImageBitmapSupported)}loadImageBitmap(e,t){return this._run("loadImageBitmap",[e,t?.data?.alphaMode])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){W===void 0&&(W=navigator.hardwareConcurrency||4);let e=this._workerPool.pop();return!e&&this._createdWorkers<W&&(this._createdWorkers++,e=new re().worker,e.addEventListener("message",t=>{this._complete(t.data),this._returnWorker(t.target),this._next()})),e}_returnWorker(e){this._workerPool.push(e)}_complete(e){this._resolveHash[e.uuid]&&(e.error!==void 0?this._resolveHash[e.uuid].reject(e.error):this._resolveHash[e.uuid].resolve(e.data),delete this._resolveHash[e.uuid])}async _run(e,t){await this._initWorkers();const a=new Promise((r,n)=>{this._queue.push({id:e,arguments:t,resolve:r,reject:n})});return this._next(),a}_next(){if(!this._queue.length)return;const e=this._getWorker();if(!e)return;const t=this._queue.pop(),a=t.id;this._resolveHash[Y]={resolve:t.resolve,reject:t.reject},e.postMessage({data:t.arguments,uuid:Y++,id:a})}reset(){this._workerPool.forEach(e=>e.terminate()),this._workerPool.length=0,Object.values(this._resolveHash).forEach(({reject:e})=>{e?.(new Error("WorkerManager has been reset before completion"))}),this._resolveHash={},this._queue.length=0,this._initialized=!1,this._createdWorkers=0}}const Z=new Xe,Ke=[".jpeg",".jpg",".png",".webp",".avif"],Qe=["image/jpeg","image/png","image/webp","image/avif"];async function Ye(s,e){const t=await A.get().fetch(s);if(!t.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${s}: ${t.status} ${t.statusText}`);const a=await t.blob();return e?.data?.alphaMode==="premultiplied-alpha"?createImageBitmap(a,{premultiplyAlpha:"none"}):createImageBitmap(a)}const ne={name:"loadTextures",id:"texture",extension:{type:f.LoadParser,priority:I.High,name:"loadTextures"},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(s){return B(s,Qe)||L(s,Ke)},async load(s,e,t){let a=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await Z.isImageBitmapSupported()?a=await Z.loadImageBitmap(s,e):a=await Ye(s,e):a=await new Promise((n,i)=>{a=A.get().createImage(),a.crossOrigin=this.config.crossOrigin,a.src=s,a.complete?n(a):(a.onload=()=>{n(a)},a.onerror=i)});const r=new ee({resource:a,alphaMode:"premultiply-alpha-on-upload",resolution:e.data?.resolution||$(s),...e.data});return V(r,t,s)},unload(s){s.destroy(!0)}},Ze=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"];let j,U;function Je(s,e,t){t===void 0&&!e.startsWith("data:")?s.crossOrigin=et(e):t!==!1&&(s.crossOrigin=typeof t=="string"?t:"anonymous")}function qe(s){return new Promise((e,t)=>{s.addEventListener("canplaythrough",a),s.addEventListener("error",r),s.load();function a(){n(),e()}function r(i){n(),t(i)}function n(){s.removeEventListener("canplaythrough",a),s.removeEventListener("error",r)}})}function et(s,e=globalThis.location){if(s.startsWith("data:"))return"";e||(e=globalThis.location);const t=new URL(s,document.baseURI);return t.hostname!==e.hostname||t.port!==e.port||t.protocol!==e.protocol?"anonymous":""}function tt(){const s=[],e=[];for(const t of Ze){const a=R.MIME_TYPES[t.substring(1)]||`video/${t.substring(1)}`;M(a)&&(s.push(t),e.includes(a)||e.push(a))}return{validVideoExtensions:s,validVideoMime:e}}const st={name:"loadVideo",id:"video",extension:{type:f.LoadParser,name:"loadVideo"},test(s){if(!j||!U){const{validVideoExtensions:a,validVideoMime:r}=tt();j=a,U=r}const e=B(s,U),t=L(s,j);return e||t},async load(s,e,t){const a={...R.defaultOptions,resolution:e.data?.resolution||$(s),alphaMode:e.data?.alphaMode||await he(),...e.data},r=document.createElement("video"),n={preload:a.autoLoad!==!1?"auto":void 0,"webkit-playsinline":a.playsinline!==!1?"":void 0,playsinline:a.playsinline!==!1?"":void 0,muted:a.muted===!0?"":void 0,loop:a.loop===!0?"":void 0,autoplay:a.autoPlay!==!1?"":void 0};Object.keys(n).forEach(d=>{const l=n[d];l!==void 0&&r.setAttribute(d,l)}),a.muted===!0&&(r.muted=!0),Je(r,s,a.crossorigin);const i=document.createElement("source");let o;if(a.mime)o=a.mime;else if(s.startsWith("data:"))o=s.slice(5,s.indexOf(";"));else if(!s.startsWith("blob:")){const d=s.split("?")[0].slice(s.lastIndexOf(".")+1).toLowerCase();o=R.MIME_TYPES[d]||`video/${d}`}return i.src=s,o&&(i.type=o),new Promise(d=>{const l=async()=>{const p=new R({...a,resource:r});r.removeEventListener("canplay",l),e.data.preload&&await qe(r),d(V(p,t,s))};a.preload&&!a.autoPlay&&r.load(),r.addEventListener("canplay",l),r.appendChild(i)})},unload(s){s.destroy(!0)}},ie={extension:{type:f.ResolveParser,name:"resolveTexture"},test:ne.test,parse:s=>({resolution:parseFloat(C.RETINA_PREFIX.exec(s)?.[1]??"1"),format:s.split(".").pop(),src:s})},at={extension:{type:f.ResolveParser,priority:-2,name:"resolveJson"},test:s=>C.RETINA_PREFIX.test(s)&&s.endsWith(".json"),parse:ie.parse};class rt{constructor(){this._detections=[],this._initialized=!1,this.resolver=new C,this.loader=new Ie,this.cache=y,this._backgroundLoader=new me(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(e={}){if(this._initialized){w("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}if(this._initialized=!0,e.defaultSearchParams&&this.resolver.setDefaultSearchParams(e.defaultSearchParams),e.basePath&&(this.resolver.basePath=e.basePath),e.bundleIdentifier&&this.resolver.setBundleIdentifier(e.bundleIdentifier),e.manifest){let n=e.manifest;typeof n=="string"&&(n=await this.load(n)),this.resolver.addManifest(n)}const t=e.texturePreference?.resolution??1,a=typeof t=="number"?[t]:t,r=await this._detectFormats({preferredFormats:e.texturePreference?.format,skipDetections:e.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:r,resolution:a}}),e.preferences&&this.setPreferences(e.preferences),e.loadOptions&&(this.loader.loadOptions={...this.loader.loadOptions,...e.loadOptions})}add(e){this.resolver.add(e)}async load(e,t){this._initialized||await this.init();const a=q(e),r=P(e).map(o=>{if(typeof o!="string"){const d=this.resolver.getAlias(o);return d.some(l=>!this.resolver.hasKey(l))&&this.add(o),Array.isArray(d)?d[0]:d}return this.resolver.hasKey(o)||this.add({alias:o,src:o}),o}),n=this.resolver.resolve(r),i=await this._mapLoadToResolve(n,t);return a?i[r[0]]:i}addBundle(e,t){this.resolver.addBundle(e,t)}async loadBundle(e,t){this._initialized||await this.init();let a=!1;typeof e=="string"&&(a=!0,e=[e]);const r=this.resolver.resolveBundle(e),n={},i=Object.keys(r);let o=0;const d=[],l=()=>{t?.(d.reduce((c,h)=>c+h,0)/o)},p=i.map((c,h)=>{const u=r[c],g=Object.values(u),v=[...new Set(g.flat())].reduce((x,O)=>x+(O.progressSize||1),0);return d.push(0),o+=v,this._mapLoadToResolve(u,x=>{d[h]=x*v,l()}).then(x=>{n[c]=x})});return await Promise.all(p),a?n[e[0]]:n}async backgroundLoad(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const t=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(t))}async backgroundLoadBundle(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const t=this.resolver.resolveBundle(e);Object.values(t).forEach(a=>{this._backgroundLoader.add(Object.values(a))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(e){if(typeof e=="string")return y.get(e);const t={};for(let a=0;a<e.length;a++)t[a]=y.get(e[a]);return t}async _mapLoadToResolve(e,t){const a=[...new Set(Object.values(e))];this._backgroundLoader.active=!1;const r=await this.loader.load(a,t);this._backgroundLoader.active=!0;const n={};return a.forEach(i=>{const o=r[i.src],d=[i.src];i.alias&&d.push(...i.alias),d.forEach(l=>{n[l]=o}),y.set(d,o)}),n}async unload(e){this._initialized||await this.init();const t=P(e).map(r=>typeof r!="string"?r.src:r),a=this.resolver.resolve(t);await this._unloadFromResolved(a)}async unloadBundle(e){this._initialized||await this.init(),e=P(e);const t=this.resolver.resolveBundle(e),a=Object.keys(t).map(r=>this._unloadFromResolved(t[r]));await Promise.all(a)}async _unloadFromResolved(e){const t=Object.values(e);t.forEach(a=>{y.remove(a.src)}),await this.loader.unload(t)}async _detectFormats(e){let t=[];e.preferredFormats&&(t=Array.isArray(e.preferredFormats)?e.preferredFormats:[e.preferredFormats]);for(const a of e.detections)e.skipDetections||await a.test()?t=await a.add(t):e.skipDetections||(t=await a.remove(t));return t=t.filter((a,r)=>t.indexOf(a)===r),t}get detections(){return this._detections}setPreferences(e){this.loader.parsers.forEach(t=>{t.config&&Object.keys(t.config).filter(a=>a in e).forEach(a=>{t.config[a]=e[a]})})}}const F=new rt;k.handleByList(f.LoadParser,F.loader.parsers).handleByList(f.ResolveParser,F.resolver.parsers).handleByList(f.CacheParser,F.cache.parsers).handleByList(f.DetectionParser,F.detections);k.add(Ae,ve,ye,Ee,be,xe,_e,Pe,Fe,Ue,$e,ne,st,ge,ue,ie,at);const J={loader:f.LoadParser,resolver:f.ResolveParser,cache:f.CacheParser,detection:f.DetectionParser};k.handle(f.Asset,s=>{const e=s.ref;Object.entries(J).filter(([t])=>!!e[t]).forEach(([t,a])=>k.add(Object.assign(e[t],{extension:e[t].extension??a})))},s=>{const e=s.ref;Object.keys(J).filter(t=>!!e[t]).forEach(t=>k.remove(e[t]))});export{F as A};
