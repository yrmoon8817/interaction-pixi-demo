import{E as D,a as S,v,T as B,j as b,M as I,l as U,F as q,w as j,R as J,I as Z,m as C}from"./index-z_3bUTQL.js";import{f as W,C as O,T as k}from"./CanvasTextMetrics-Bea0LAic.js";import{C as H}from"./CanvasPool-D7UiZzQ0.js";class Q extends D{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return S(v,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return S(v,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return S(v,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return S(v,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return S(v,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){var e;this.emit("destroy",this),this.removeAllListeners();for(const s in this.chars)(e=this.chars[s].texture)==null||e.destroy();this.chars=null,t&&(this.pages.forEach(s=>s.texture.destroy(!0)),this.pages=null)}}const L=1e5;function E(h,t,e,s=0){if(h.texture===B.WHITE&&!h.fill)return b.shared.setValue(h.color).setAlpha(h.alpha??1).toHexa();if(h.fill){if(h.fill instanceof U){const i=h.fill,n=t.createPattern(i.texture.source.resource,"repeat"),r=i.transform.copyTo(I.shared);return r.scale(i.texture.frame.width,i.texture.frame.height),n.setTransform(r),n}else if(h.fill instanceof q){const i=h.fill,n=i.type==="linear",r=i.textureSpace==="local";let a=1,o=1;r&&e&&(a=e.width+s,o=e.height+s);let l,d=!1;if(n){const{start:c,end:p}=i;l=t.createLinearGradient(c.x*a,c.y*o,p.x*a,p.y*o),d=Math.abs(p.x-c.x)<Math.abs((p.y-c.y)*.1)}else{const{center:c,innerRadius:p,outerCenter:g,outerRadius:u}=i;l=t.createRadialGradient(c.x*a,c.y*o,p*a,g.x*a,g.y*o,u*a)}if(d&&r&&e){const c=e.lineHeight/o;for(let p=0;p<e.lines.length;p++){const g=(p*e.lineHeight+s/2)/o;i.colorStops.forEach(u=>{const f=g+u.offset*c;l.addColorStop(Math.floor(f*L)/L,b.shared.setValue(u.color).toHex())})}}else i.colorStops.forEach(c=>{l.addColorStop(c.offset,b.shared.setValue(c.color).toHex())});return l}}else{const i=t.createPattern(h.texture.source.resource,"repeat"),n=h.matrix.copyTo(I.shared);return n.scale(h.texture.frame.width,h.texture.frame.height),i.setTransform(n),i}return j("FillStyle not recognised",h),"red"}function K(h){if(h==="")return[];typeof h=="string"&&(h=[h]);const t=[];for(let e=0,s=h.length;e<s;e++){const i=h[e];if(Array.isArray(i)){if(i.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);if(i[0].length===0||i[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=i[0].charCodeAt(0),r=i[1].charCodeAt(0);if(r<n)throw new Error("[BitmapFont]: Invalid character range.");for(let a=n,o=r;a<=o;a++)t.push(String.fromCharCode(a))}else t.push(...Array.from(i))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}const $=class Y extends Q{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const e={...Y.defaultOptions,...t};this._textureSize=e.textureSize,this._mipmap=e.mipmap;const s=e.style.clone();e.overrideFill&&(s._fill.color=16777215,s._fill.alpha=1,s._fill.texture=B.WHITE,s._fill.fill=null),this.applyFillAsTint=e.overrideFill;const i=s.fontSize;s.fontSize=this.baseMeasurementFontSize;const n=W(s);e.overrideSize?s._stroke&&(s._stroke.width*=this.baseRenderedFontSize/i):s.fontSize=this.baseRenderedFontSize=i,this._style=s,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,this.fontMetrics=O.measureFont(n),this.lineHeight=s.lineHeight||this.fontMetrics.fontSize||s.fontSize}ensureCharacters(t){var m,F;const e=K(t).filter(_=>!this._currentChars.includes(_)).filter((_,x,w)=>w.indexOf(_)===x);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let s;this._currentPageIndex===-1?s=this._nextPage():s=this.pages[this._currentPageIndex];let{canvas:i,context:n}=s.canvasAndContext,r=s.texture.source;const a=this._style;let o=this._currentX,l=this._currentY;const d=this.baseRenderedFontSize/this.baseMeasurementFontSize,c=this._padding*d;let p=0,g=!1;const u=i.width/this.resolution,f=i.height/this.resolution;for(let _=0;_<e.length;_++){const x=e[_],w=O.measureText(x,a,i,!1);w.lineHeight=w.height;const y=w.width*d,G=Math.ceil((a.fontStyle==="italic"?2:1)*y),N=w.height*d,A=G+c*2,P=N+c*2;if(g=!1,x!==`
`&&x!=="\r"&&x!=="	"&&x!==" "&&(g=!0,p=Math.ceil(Math.max(P,p))),o+A>u&&(l+=p,p=P,o=0,l+p>f)){r.update();const z=this._nextPage();i=z.canvasAndContext.canvas,n=z.canvasAndContext.context,r=z.texture.source,l=0}const X=y/d-(((m=a.dropShadow)==null?void 0:m.distance)??0)-(((F=a._stroke)==null?void 0:F.width)??0);if(this.chars[x]={id:x.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:X,kerning:{}},g){this._drawGlyph(n,w,o+c,l+c,d,a);const z=r.width*d,M=r.height*d,V=new J(o/z*r.width,l/M*r.height,A/z*r.width,P/M*r.height);this.chars[x].texture=new B({source:r,frame:V}),o+=Math.ceil(A)}}r.update(),this._currentX=o,this._currentY=l,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return S(v,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const s=this._measureCache;for(let i=0;i<t.length;i++){const n=t[i];for(let r=0;r<this._currentChars.length;r++){const a=this._currentChars[r];let o=s[n];o||(o=s[n]=e.measureText(n).width);let l=s[a];l||(l=s[a]=e.measureText(a).width);let d=e.measureText(n+a).width,c=d-(o+l);c&&(this.chars[n].kerning[a]=c),d=e.measureText(n+a).width,c=d-(o+l),c&&(this.chars[a].kerning[n]=c)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=H.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const s=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),i=new B({source:new Z({resource:e.canvas,resolution:s,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})}),n={canvasAndContext:e,texture:i};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,s){e.fontSize=this.baseRenderedFontSize,t.scale(s,s),t.font=W(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const i=e._stroke,n=(i==null?void 0:i.width)??0;if(i&&(t.lineWidth=n,t.lineJoin=i.join,t.miterLimit=i.miterLimit,t.strokeStyle=E(i,t)),e._fill&&(t.fillStyle=E(e._fill,t)),e.dropShadow){const r=e.dropShadow,a=b.shared.setValue(r.color).toArray(),o=r.blur*s,l=r.distance*s;t.shadowColor=`rgba(${a[0]*255},${a[1]*255},${a[2]*255},${r.alpha})`,t.shadowBlur=o,t.shadowOffsetX=Math.cos(r.angle)*l,t.shadowOffsetY=Math.sin(r.angle)*l}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,s,i,n,r){const a=e.text,o=e.fontProperties,l=r._stroke,d=((l==null?void 0:l.width)??0)*n,c=s+d/2,p=i-d/2,g=o.descent*n,u=e.lineHeight*n;r.stroke&&d&&t.strokeText(a,c,p+u-g),r._fill&&t.fillText(a,c,p+u-g)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:s}=this.pages[t];H.returnCanvasAndContext(e),s.destroy(!0)}this.pages=null}};$.defaultOptions={textureSize:512,style:new k,mipmap:!0};let R=$;function ee(h,t,e,s){const i={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};i.offsetY=e.baseLineOffset;let n=i.lines[0],r=null,a=!0;const o={width:0,start:0,index:0,positions:[],chars:[]},l=u=>{const f=n.width;for(let m=0;m<o.index;m++){const F=u.positions[m];n.chars.push(u.chars[m]),n.charPositions.push(F+f)}n.width+=u.width,a=!1,o.width=0,o.index=0,o.chars.length=0},d=()=>{let u=n.chars.length-1;if(s){let f=n.chars[u];for(;f===" ";)n.width-=e.chars[f].xAdvance,f=n.chars[--u]}i.width=Math.max(i.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},a=!0,i.lines.push(n),i.height+=e.lineHeight},c=e.baseMeasurementFontSize/t.fontSize,p=t.letterSpacing*c,g=t.wordWrapWidth*c;for(let u=0;u<h.length+1;u++){let f;const m=u===h.length;m||(f=h[u]);const F=e.chars[f]||e.chars[" "];if(/(?:\s)/.test(f)||f==="\r"||f===`
`||m){if(!a&&t.wordWrap&&n.width+o.width-p>g?(d(),l(o),m||n.charPositions.push(0)):(o.start=n.width,l(o),m||n.charPositions.push(0)),f==="\r"||f===`
`)n.width!==0&&d();else if(!m){const y=F.xAdvance+(F.kerning[r]||0)+p;n.width+=y,n.spaceWidth=y,n.spacesIndex.push(n.charPositions.length),n.chars.push(f)}}else{const w=F.kerning[r]||0,y=F.xAdvance+w+p;o.positions[o.index++]=o.width+w,o.chars.push(f),o.width+=y}r=f}return d(),t.align==="center"?te(i):t.align==="right"?ie(i):t.align==="justify"&&se(i),i}function te(h){for(let t=0;t<h.lines.length;t++){const e=h.lines[t],s=h.width/2-e.width/2;for(let i=0;i<e.charPositions.length;i++)e.charPositions[i]+=s}}function ie(h){for(let t=0;t<h.lines.length;t++){const e=h.lines[t],s=h.width-e.width;for(let i=0;i<e.charPositions.length;i++)e.charPositions[i]+=s}}function se(h){const t=h.width;for(let e=0;e<h.lines.length;e++){const s=h.lines[e];let i=0,n=s.spacesIndex[i++],r=0;const a=s.spacesIndex.length,l=(t-s.width)/a;for(let d=0;d<s.charPositions.length;d++)d===n&&(n=s.spacesIndex[i++],r+=l),s.charPositions[d]+=r}}let T=0;class ne{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(t,e){var r;let s=`${e.fontFamily}-bitmap`,i=!0;if(e._fill.fill&&!e._stroke)s+=e._fill.fill.styleKey,i=!1;else if(e._stroke||e.dropShadow){let a=e.styleKey;a=a.substring(0,a.lastIndexOf("-")),s=`${a}-bitmap`,i=!1}if(!C.has(s)){const a=new R({style:e,overrideFill:i,overrideSize:!0,...this.defaultOptions});T++,T>50&&j("BitmapText",`You have dynamically created ${T} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),a.once("destroy",()=>{T--,C.remove(s)}),C.set(s,a)}const n=C.get(s);return(r=n.ensureCharacters)==null||r.call(n,t),n}getLayout(t,e,s=!0){const i=this.getFont(t,e);return ee([...t],e,i,s)}measureText(t,e,s=!0){return this.getLayout(t,e,s)}install(...t){var l,d,c,p;let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:(l=t[2])==null?void 0:l.chars,resolution:(d=t[2])==null?void 0:d.resolution,padding:(c=t[2])==null?void 0:c.padding,skipKerning:(p=t[2])==null?void 0:p.skipKerning},S(v,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const s=e==null?void 0:e.name;if(!s)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const i=e.style,n=i instanceof k?i:new k(i),r=n._fill.fill!==null&&n._fill.fill!==void 0,a=new R({style:n,overrideFill:r,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1}),o=K(e.chars);return a.ensureCharacters(o.join("")),C.set(`${s}-bitmap`,a),a.once("destroy",()=>C.remove(`${s}-bitmap`)),a}uninstall(t){const e=`${t}-bitmap`,s=C.get(e);s&&s.destroy()}}const he=new ne;export{Q as A,he as B,E as a,ee as g};
